- 所有权转移
	- 深拷贝所有权不会转移，浅拷贝所有权会转移
		- ```
		  fn string_ts(){
		      let mut a  = String::from("hello");
		      a.push_str(", world!");
		      // let b = a;
		      println!("{}", a);
		      let b = a.clone();
		      println!("a: {} b: {}", a,b);
		      let c = a;
		      // println!("a: {} b: {} c: {}", a,b,c);
		      // 结论：深拷贝所有权不会转移，浅拷贝所有权会转移
		  }
		  ```
	- 以下类型是拥有所有权的类型
		- ```
		  String：代表动态可变字符串，拥有所有权并负责其内存管理。
		  
		  Vec<T>：代表动态可变数组，拥有所有权并负责其内存管理。
		  
		  Box<T>：代表堆上分配的值的所有权。
		  
		  Rc<T>：代表引用计数智能指针，允许多个所有者共享数据。
		  
		  Arc<T>：代表线程安全的引用计数智能指针，允许多个线程共享数据。
		  
		  Mutex<T>：代表互斥锁，用于在多线程环境中保护共享数据的访问。
		  
		  Cell<T> 和 RefCell<T>：代表内部可变性，允许在不可变引用的情况下修改值。
		  
		  自定义类型：你也可以在自己的结构体或枚举类型中实现拥有所有权的语义。
		  ```
- 借用规则
	- 同一时刻，一个变量只能拥有要么一个可变引用, 要么任意多个不可变引用
		- ```
		  let mut s = String::from("hello");
		  
		  let r1 = &s; // 没问题
		  let r2 = &s; // 没问题
		  let r3 = &mut s; // 大问题
		  
		  println!("{}, {}, and {}", r1, r2, r3);
		  ```
	- 引用必须总是有效的