- ## first
- 规范
	- 不要用没有实际意义的词语命名,变量或者函数尽可能做到见名知意
		- deleteMailNew
		- DeleteMailNewEvent
		- DeleteMailItemNew
	- 变量名可以简短一些
		- hasAttachUnDelEmail=>attachEmail
		- hasNoAttachUnDelEmail=>noAttachEmail
	- 命名规范保持一致
		- t := uint32(MailItem.GetType())
	- 重复的使用的定义变量
		- emailSendTime+int64(expireDaysVal)*3600*24
			- 建议定义一个白能量
		- int64(time.Now().Unix())
			- 有多处使用，如果不定义变量这个值还一致吗
	- 遍历
		- 建议遍历数据的变量使用k=>v、kk=>vv...的结构
		- ```
		  func delMaildataByOnlyId(data *serverproto.MailSaveData, onlyId string) *serverproto.MailSaveData {
		  	var find bool
		  	for a, mailMap_a := range data.GetMailMap() {
		  		for b, MailItem_b := range mailMap_a.GetList() {
		  			if onlyId == MailItem_b.GetOnlyId() {
		  				data.MailMap[a].List = append(data.MailMap[a].List[:b], data.MailMap[a].List[b+1:]...)
		  				find = true
		  				break
		  			}
		  		}
		  		if find {
		  			break
		  		}
		  	}
		  	return data
		  }
		  ```
	- 错误处理
		- 建议看一下别的错误处理方式，“:”后加上空格，这样统一些，在查询日志文件时更清晰
		- ```
		  log.Errorf("remove mail user: %d list: %v err: %s", userId, onlyIds, err)
		  ```
- 函数
	- 重复的功能可以封装一下函数
		- ```
		  expireDays, err := model.GetConstValueConfigById(uint32(configproto.Define_Mail2502)) // 30
		  	if err != nil {
		  		return nil, errors.SetFailedError(err)
		  	}
		  	expireDaysVal := expireDays.GetValue()
		  
		  	EmailSaveLimitCount, err := model.GetConstValueConfigById(uint32(configproto.Define_Mail2501)) // 30
		  	if err != nil {
		  		return nil, errors.SetFailedError(err)
		  	}
		  	EmailSaveLimitCountVal := EmailSaveLimitCount.GetValue()
		  ```
	- sortEmailByTime
		- 该函数是否实现了排序功能，测试一下
		- 建议看看go提供的sort包的slice方法
	- getKeys1
		- 建议使用泛型更通用一些
	- checkAutoDelEmailListTime
		- 不用的函数就删除掉
- 逻辑
	- 建议先判断过期，在判断有无附件
		- ```
		  if len(MailItem.GetReward()) > 0 {
		  				if emailSendTime+int64(expireDaysVal)*3600*24 <= int64(time.Now().Unix()) {
		  					delOnlyIds = append(delOnlyIds, onlyId)
		  					data = delMaildataByOnlyId(data, onlyId)
		  				} else {
		  					hasAttachUnDelEmail = append(hasAttachUnDelEmail, sortEmail{
		  						onlyId, emailSendTime,
		  					})
		  				}
		  			} else {
		  				if emailSendTime+int64(expireDaysVal)*3600*24 <= int64(time.Now().Unix()) {
		  					delOnlyIds = append(delOnlyIds, onlyId)
		  					data = delMaildataByOnlyId(data, onlyId)
		  				} else {
		  					noAttachUnDelEmail = append(noAttachUnDelEmail, sortEmail{
		  						onlyId, emailSendTime,
		  					})
		  				}
		  			}
		  ```
	- 超过100条优先处理
		- 最优：创建的时候就限制100条
		- 其次：当前逻辑查询的时候，直接按时间排序删除100条之外的，无需判断有无附件
- ## second
- 优化
	- v.GetValue()可以直接返回,没必要赋值后返回
	- ```
	  func getConstValue(id uint32) (uint32, error) {
	  	v, err := model.GetConstValueConfigById(id) // 30
	  	if err != nil {
	  		return 0, errors.SetFailedError(err)
	  	}
	  	val := v.GetValue()
	  	return val, nil
	  }
	  ```
- marshal时不要忽略错误
	- ```
	  jsonData, _ := json.Marshal(data)
	  	json.Unmarshal([]byte(jsonData), &result)
	  ```
- 可以直接赋值
	- ```
	  typ := uint32(MailItem.GetType())
	  			onlyIdMailTypeMap[onlyId] = typ
	  ```
- 指针引用传值
	- 建议方法使用指针引用传值,而不是使用同一个参数和返回值
		- delMaildataByOnlyId
		- getDelMailOnlyIds
		- ```
		  delOnlyIds = getDelMailOnlyIds(noAttachEmail, delOnlyIds, last)
		  			delOnlyIds = getDelMailOnlyIds(attachEmail, delOnlyIds, last)
		  ```
- 重复的逻辑
	- 两次 if len(delOnlyIds)  判断的意义?
	- ```
	  if len(delOnlyIds) > 0 {
	  		for _, onlyId := range delOnlyIds {
	  			data = delMaildataByOnlyId(data, onlyId)
	  		}
	  	}
	  
	  	if len(delOnlyIds) > 0 {
	  		// 删除不符合条件的邮件列表
	  		if err := DeleteMailItem(ctx, data.GetUserId(), delOnlyIds); err != nil {
	  			return nil, errors.SetFailedError(err)
	  		}
	  	}
	  ```
- 跳出多层for循环
	- 建议使用标记跳出
		- ```
		  ```