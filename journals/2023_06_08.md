- 规范
	- 不要用没有实际意义的词语命名,变量或者函数尽可能做到见名知意
		- deleteMailNew
		- DeleteMailNewEvent
		- DeleteMailItemNew
	- 变量名可以简短一些
		- hasAttachUnDelEmail=>attachEmail
		- hasNoAttachUnDelEmail=>noAttachEmail
	- 命名规范保持一致
		- t := uint32(MailItem.GetType())
	- 重复的使用的定义变量
		- emailSendTime+int64(expireDaysVal)*3600*24
			- 建议定义一个白能量
		- int64(time.Now().Unix())
			- 有多处使用，如果不定义变量这个值还一致吗
	- 遍历
		- 建议遍历数据的变量使用k=>v、kk=>vv...的结构
		- ```
		  func delMaildataByOnlyId(data *serverproto.MailSaveData, onlyId string) *serverproto.MailSaveData {
		  	var find bool
		  	for a, mailMap_a := range data.GetMailMap() {
		  		for b, MailItem_b := range mailMap_a.GetList() {
		  			if onlyId == MailItem_b.GetOnlyId() {
		  				data.MailMap[a].List = append(data.MailMap[a].List[:b], data.MailMap[a].List[b+1:]...)
		  				find = true
		  				break
		  			}
		  		}
		  		if find {
		  			break
		  		}
		  	}
		  	return data
		  }
		  ```
	- 错误处理
		- 建议看一下别的错误处理方式，“:”后加上空格，这样统一一些，在查询日志文件时
		- ```
		  log.Errorf("remove mail user:%d list:%v err:%s", userId, onlyIds, err)
		  ```
- 函数
	- 重复的功能可以封装一下函数
		- ```
		  expireDays, err := model.GetConstValueConfigById(uint32(configproto.Define_Mail2502)) // 30
		  	if err != nil {
		  		return nil, errors.SetFailedError(err)
		  	}
		  	expireDaysVal := expireDays.GetValue()
		  
		  	EmailSaveLimitCount, err := model.GetConstValueConfigById(uint32(configproto.Define_Mail2501)) // 30
		  	if err != nil {
		  		return nil, errors.SetFailedError(err)
		  	}
		  	EmailSaveLimitCountVal := EmailSaveLimitCount.GetValue()
		  ```
	- sortEmailByTime
		- 该函数是否实现了排序功能，测试一下
		- 建议看看go提供的sort包的slice方法
	- getKeys1
		- 建议使用泛型更通用一些
	- checkAutoDelEmailListTime
		- 不用的函数就删除掉
- 逻辑
	- 建议先判断过期，在判断有无附件
		- ```
		  if len(MailItem.GetReward()) > 0 {
		  				if emailSendTime+int64(expireDaysVal)*3600*24 <= int64(time.Now().Unix()) {
		  					delOnlyIds = append(delOnlyIds, onlyId)
		  					data = delMaildataByOnlyId(data, onlyId)
		  				} else {
		  					hasAttachUnDelEmail = append(hasAttachUnDelEmail, sortEmail{
		  						onlyId, emailSendTime,
		  					})
		  				}
		  			} else {
		  				if emailSendTime+int64(expireDaysVal)*3600*24 <= int64(time.Now().Unix()) {
		  					delOnlyIds = append(delOnlyIds, onlyId)
		  					data = delMaildataByOnlyId(data, onlyId)
		  				} else {
		  					noAttachUnDelEmail = append(noAttachUnDelEmail, sortEmail{
		  						onlyId, emailSendTime,
		  					})
		  				}
		  			}
		  ```
	- 超过100条优先处理
		- 最优：创建的时候就限制100条
		- 其次：当前逻辑查询的时候，直接按时间排序删除100条之外的，无需判断有误附件